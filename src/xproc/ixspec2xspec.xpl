<?xml version="1.0" encoding="UTF-8"?>
<p:declare-step
    xmlns:c="http://www.w3.org/ns/xproc-step"
    xmlns:ix="http://xylarium.org/ns/xml/ixspec"
    xmlns:ixp="http://xylarium.org/ns/xproc/steps/ixspec"  
    xmlns:m="http://xylarium.org/ns/xml/documentation"
    xmlns:map="http://www.w3.org/2005/xpath-functions/map"
    xmlns:p="http://www.w3.org/ns/xproc"      
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:x="http://www.jenitennison.com/xslt/xspec"     
    xmlns:u="http://xylarium.org/ns/xproc/steps/utils"   
    exclude-inline-prefixes="#all"
    name="ixspec2xspec"
    type="ixp:ixspec2xspec"
    version="3.0">
    
	<p:documentation>
		<m:document>
			<m:title>iXSpec to XSpec</m:title>
			<m:desc>
				<m:p>Converts an iXSpec file into an XSpec file.</m:p>
			</m:desc>
			<m:note>An unofficial extension of the <m:link href="https://github.com/xspec/xspec/blob/master/src/xproc3/harness-lib.xpl">official XProc library for XSpec</m:link></m:note>
			<m:contributors>
				<m:original-author>Sheila Thomson</m:original-author>
			</m:contributors>
			<m:history created="2024-10-04">
				<m:change date="2025-08-14">
					<m:desc>Refactored to for greater compatibility with XSpec's XProc 3 library.</m:desc>
				</m:change>
			</m:history>
		</m:document>
	</p:documentation>
    
    
	<p:import href="http://www.jenitennison.com/xslt/xspec/xproc/lib"/>

	<p:documentation>
		<m:component>An iXSpec test file.</m:component>
	</p:documentation>  
    <p:input port="source" sequence="false" primary="true" content-types="xml" />
		
		
	<p:documentation>
		<m:component>The iXSpec test file after it's been converted to XSpec but before it's been through the XSpec compile process.</m:component>
	</p:documentation>			
    <p:output port="result" sequence="true">
    	<p:pipe port="result" step="delete-grammar-ref" />
    </p:output>
	
	
	<p:documentation>
		<m:component>
			<m:desc>
				<m:p>A map of parameter options and their values.</m:p>
				<m:ul>
					<m:ingress>The options supported by this step are:</m:ingress>
					<m:li><m:code>xspec-home</m:code> - a path to the XSpec framework root directory (required)</m:li>
					<m:li><m:code>log-ixml</m:code> - a path to the directory where the XML generated by the Invisible XML conversion should be stored (required)</m:li>
					<m:li><m:code>log-ixspec</m:code> - a path to where the original iXSpec source file should be logged/stored (optional)</m:li>
					<m:li><m:code>log-xspec</m:code> - a path to where the result of the iXSPec-to-XSpec conversion should be logged/stored (optional)</m:li>
				</m:ul>				
			</m:desc>
			<m:note>If <m:code>parameters</m:code> isn't set to an empty map by default then an error is thrown by <m:code>x:compile-xslt</m:code> in <m:code>harness-lib.xpl</m:code> when map:get() is used (because <m:code>map:get()</m:code> requires a map).</m:note>
		</m:component>
	</p:documentation>	
	<p:option name="parameters" select="map{}" as="map(xs:QName,item()*)" static="true" />
	
	<p:option name="tmp-dir" select="'../tmp/'" as="xs:anyURI" />
	
	<p:option name="debug" select="false()" as="xs:boolean" static="true" />
	<p:option name="debug-dir" select="'../tmp/debug/'" as="xs:anyURI?" />
	
 
	<p:variable name="tmp-base-path" select="string-join(($tmp-dir, 'ixspec2xspec'), '/')" />	
	<p:variable name="debug-base-path" select="string-join(($debug-dir, 'ixspec2xspec'), '/')" />

	<p:variable name="test-file-base-uri" select="document-uri(/)" as="xs:anyURI" />
	<p:variable name="test-file-name" select="tokenize($test-file-base-uri, '/')[last()] ! string-join(tokenize(., '\.')[position() != last()], '.')" as="xs:string" />

	<p:variable name="dynamic-parameters" select="$parameters" as="map(xs:QName,item()*)" />
	<p:variable name="dynamic-parameters" select="map:put($dynamic-parameters, 'log-ixspec', concat($debug-base-path, '/', $test-file-name, '.ixspec'))" as="map(xs:QName,item()*)" use-when="($debug and map:get($parameters, xs:QName('log-ixspec') = ''))" />
	<p:variable name="dynamic-parameters" select="map:put($dynamic-parameters, 'log-ixspec-pre-new-contexts', concat($debug-base-path, '/', $test-file-name, '.pre_new_contexts.xml'))" as="map(xs:QName,item()*)" use-when="($debug and map:get($parameters, xs:QName('log-ixspec') = ''))" />
	<p:variable name="dynamic-parameters" select="map:put($dynamic-parameters, 'log-ixspec-new-contexts', concat($debug-base-path, '/', $test-file-name, '.new_contexts.xml'))" as="map(xs:QName,item()*)" use-when="($debug and map:get($parameters, xs:QName('log-ixspec') = ''))" />
	<p:variable name="dynamic-parameters" select="map:put($dynamic-parameters, 'log-xspec', concat($debug-base-path, '/', $test-file-name, '.xspec'))" as="map(xs:QName,item()*)" use-when="($debug and map:get($parameters, xs:QName('log-xspec') = ''))" />

	<x:log if-set="log-ixspec">
		<p:with-option name="parameters" select="$dynamic-parameters"/>         
	</x:log>

	
	<p:namespace-rename from="http://xylarium.org/ns/xml/ixspec" to="http://www.jenitennison.com/xslt/xspec" />
	<p:add-attribute match="/*" attribute-name="stylesheet" attribute-value="http://xylarium.org/ns/xslt/utils/identity.xsl" />
	
	<x:log if-set="log-ixspec-pre-new-contexts">
		<p:with-option name="parameters" select="$dynamic-parameters"/>         
	</x:log>


	<p:viewport name="update-context-href"
		match="/x:description/descendant-or-self::x:scenario[x:context/@href][not(@pending)]">
		
		<p:output port="result" sequence="true">
			<p:pipe step="updated-context" port="result" />
		</p:output>
		
		<p:identity name="current-scenario" />
		
		<p:variable name="original-context-href" select="resolve-uri(/x:scenario/x:context/@href, $test-file-base-uri)" />
		<p:variable name="scenario-tmp-base-path" select="string-join(($tmp-base-path, $test-file-name, 'update-context-href', p:iteration-position()), '/')" />
		<p:variable name="scenario-debug-base-path" select="string-join(($debug-base-path, $test-file-name, 'update-context-href', p:iteration-position()), '/')" />
		<p:variable name="new-context-href" select="/*/text()">
			<p:pipe step="new-context" port="result-uri" />
		</p:variable>	
		
		<p:sink />
		
		<p:load href="{$original-context-href}" content-type="text/plain" />
		
		<p:invisible-xml>
			<p:with-input port="grammar" pipe="result@grammar" />
		</p:invisible-xml>
		
		<p:store name="new-context">
			<p:with-option name="href" select="concat($scenario-tmp-base-path, '.ixml-output.xml')" />
			<p:with-option name="serialization" select="map { 'method' : 'xml', 'indent' : false() }" />
		</p:store>
		
		<p:sink />
		
		
		<p:xslt name="updated-context">		
			<p:with-input port="source" pipe="result@current-scenario" />
			<p:with-input port="stylesheet">
				<p:document href="../xslt/update_context_href.xsl" />
			</p:with-input>
			<p:with-option name="parameters" select="map { 'new-context-href': $new-context-href }" />
		</p:xslt>
		
	</p:viewport>
	
	<x:log if-set="log-ixspec-new-contexts">
		<p:with-option name="parameters" select="$dynamic-parameters"/>         
	</x:log>
	
	
	<p:viewport name="update-expect-href"
		match="/x:description/descendant-or-self::x:scenario[x:expect/@href][not(@pending)]">
		
		<p:output port="result" sequence="true" />
		
		<p:variable name="resolved-expect-href" select="resolve-uri(/x:scenario/x:expect/@href, $test-file-base-uri)" />
		<p:variable name="scenario-tmp-base-path" select="string-join(($tmp-base-path, $test-file-name, 'update-expect-href', p:iteration-position()), '/')" />
		<p:variable name="scenario-debug-base-path" select="string-join(($debug-base-path, $test-file-name, 'update-expect-href', p:iteration-position()), '/')" />
	
		<p:xslt name="updated-expect">
			<p:with-input port="stylesheet">
				<p:document href="../xslt/update_expect_href.xsl" />
			</p:with-input>
			<p:with-option name="parameters" select="map { 'new-expect-href': $resolved-expect-href }" />
		</p:xslt>
		
	</p:viewport>
	
	<p:delete match="/*/@grammar" name="delete-grammar-ref" />
	
	<x:log if-set="log-xspec">
		<p:with-option name="parameters" select="$dynamic-parameters"/>         
	</x:log>
                   
    <p:sink />   
	
	
	<p:identity>
		<p:with-input port="source" pipe="source@ixspec2xspec" />
	</p:identity>
	
	<p:variable name="grammar-href" select="xs:anyURI(/ix:description/@grammar)" as="xs:anyURI" />
	
	<p:load name="grammar">
		<p:with-option name="href" select="$grammar-href" />
	</p:load>
	
	<p:sink />
	
</p:declare-step>